"""
SQLite Í∏∞Î∞ò ÏãúÏû• Îç∞Ïù¥ÌÑ∞ Í¥ÄÎ¶¨Ïûê

ÏóÖÎπÑÌä∏ Îì± Îã§ÏñëÌïú ÌîÑÎ°úÎ∞îÏù¥ÎçîÏùò ÏãúÏû• Îç∞Ïù¥ÌÑ∞Î•º SQLiteÏóê Ï†ÄÏû•ÌïòÍ≥† Í¥ÄÎ¶¨ÌïòÎäî ÌÅ¥ÎûòÏä§
"""

import sqlite3
import json
from pathlib import Path
from datetime import datetime, timezone, timedelta
from typing import List, Dict, Optional
import polars as pl

# config.pyÏóêÏÑú Ï†àÎåÄÍ≤ΩÎ°ú import
try:
    from ...config import DB_PATH
except ImportError:
    # config.pyÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞ Í∏∞Î≥∏Í∞í
    DB_PATH = "/home/lazydok/src/quantbt/data/quantbt.db"


class DatabaseManager:
    """SQLite Í∏∞Î∞ò ÏãúÏû• Îç∞Ïù¥ÌÑ∞ Í¥ÄÎ¶¨Ïûê"""
    
    def __init__(self, db_path: str = None):
        if db_path is None:
            db_path = DB_PATH
        
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self.init_database()
    
    def init_database(self):
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î∞è ÌÖåÏù¥Î∏î Ï¥àÍ∏∞Ìôî"""
        with sqlite3.connect(self.db_path) as conn:
            # ÏãúÏû• Îç∞Ïù¥ÌÑ∞ ÌÖåÏù¥Î∏î
            conn.execute('''
                CREATE TABLE IF NOT EXISTS market_data (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    provider TEXT NOT NULL,
                    symbol TEXT NOT NULL,
                    timeframe TEXT NOT NULL,
                    timestamp_utc DATETIME NOT NULL,
                    timestamp_kst DATETIME NOT NULL,
                    open_price REAL NOT NULL,
                    high_price REAL NOT NULL,
                    low_price REAL NOT NULL,
                    close_price REAL NOT NULL,
                    volume REAL NOT NULL,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(provider, symbol, timeframe, timestamp_utc)
                )
            ''')
            
            # Ïù∏Îç±Ïä§ ÏÉùÏÑ±
            conn.execute('''
                CREATE INDEX IF NOT EXISTS idx_market_data_lookup 
                ON market_data(provider, symbol, timeframe, timestamp_utc)
            ''')
            
            # Ï∫êÏãú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÌÖåÏù¥Î∏î (Í∏∞Ï°¥ Î≤ÑÏ†Ñ)
            conn.execute('''
                CREATE TABLE IF NOT EXISTS cache_metadata (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    cache_key TEXT UNIQUE NOT NULL,
                    file_path TEXT NOT NULL,
                    start_time_utc DATETIME NOT NULL,
                    end_time_utc DATETIME NOT NULL,
                    record_count INTEGER NOT NULL,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    last_accessed DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # ÏÉàÎ°úÏö¥ Ïª¨ÎüºÎì§ Ï∂îÍ∞Ä (ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò)
            self._migrate_cache_metadata_table(conn)
            
            conn.execute('''
                CREATE INDEX IF NOT EXISTS idx_cache_lookup 
                ON cache_metadata(cache_key)
            ''')
            
            # ÏÉàÎ°úÏö¥ Ïù∏Îç±Ïä§Îì§ Ï∂îÍ∞Ä
            conn.execute('''
                CREATE INDEX IF NOT EXISTS idx_cache_provider_symbol_timeframe 
                ON cache_metadata(provider, symbol, timeframe)
            ''')
            
            conn.execute('''
                CREATE INDEX IF NOT EXISTS idx_cache_timeframe 
                ON cache_metadata(timeframe)
            ''')
            
            conn.commit()
    
    def _migrate_cache_metadata_table(self, conn):
        """Ï∫êÏãú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÌÖåÏù¥Î∏î ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò"""
        try:
            # Í∏∞Ï°¥ Ïª¨Îüº ÌôïÏù∏
            cursor = conn.execute("PRAGMA table_info(cache_metadata)")
            columns = [row[1] for row in cursor.fetchall()]
            
            # provider Ïª¨Îüº Ï∂îÍ∞Ä
            if 'provider' not in columns:
                conn.execute('ALTER TABLE cache_metadata ADD COLUMN provider TEXT')
                print("üìù Ï∫êÏãú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Ïóê provider Ïª¨Îüº Ï∂îÍ∞Ä")
            
            # symbol Ïª¨Îüº Ï∂îÍ∞Ä
            if 'symbol' not in columns:
                conn.execute('ALTER TABLE cache_metadata ADD COLUMN symbol TEXT')
                print("üìù Ï∫êÏãú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Ïóê symbol Ïª¨Îüº Ï∂îÍ∞Ä")
            
            # timeframe Ïª¨Îüº Ï∂îÍ∞Ä
            if 'timeframe' not in columns:
                conn.execute('ALTER TABLE cache_metadata ADD COLUMN timeframe TEXT')
                print("üìù Ï∫êÏãú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Ïóê timeframe Ïª¨Îüº Ï∂îÍ∞Ä")
            
            # data_source Ïª¨Îüº Ï∂îÍ∞Ä (Ï∂îÍ∞Ä Ï†ïÎ≥¥Î•º ÏúÑÌï¥)
            if 'data_source' not in columns:
                conn.execute('ALTER TABLE cache_metadata ADD COLUMN data_source TEXT DEFAULT "api"')
                print("üìù Ï∫êÏãú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Ïóê data_source Ïª¨Îüº Ï∂îÍ∞Ä")
            
        except Exception as e:
            print(f"‚ö†Ô∏è Ï∫êÏãú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ï§ë Ïò§Î•ò: {e}")
    
    def get_cache_metadata_by_criteria(self, provider: str = None, symbol: str = None, 
                                     timeframe: str = None) -> List[Dict]:
        """Ï°∞Í±¥Î≥Ñ Ï∫êÏãú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
        with sqlite3.connect(self.db_path) as conn:
            where_conditions = []
            params = []
            
            if provider:
                where_conditions.append("provider = ?")
                params.append(provider)
            
            if symbol:
                where_conditions.append("symbol = ?")
                params.append(symbol)
            
            if timeframe:
                where_conditions.append("timeframe = ?")
                params.append(timeframe)
            
            where_clause = ""
            if where_conditions:
                where_clause = "WHERE " + " AND ".join(where_conditions)
            
            query = f'''
                SELECT cache_key, file_path, provider, symbol, timeframe,
                       start_time_utc, end_time_utc, record_count,
                       created_at, last_accessed, data_source
                FROM cache_metadata 
                {where_clause}
                ORDER BY created_at DESC
            '''
            
            cursor = conn.execute(query, params)
            columns = [description[0] for description in cursor.description]
            
            results = []
            for row in cursor.fetchall():
                result_dict = dict(zip(columns, row))
                results.append(result_dict)
            
            return results
    
    def save_market_data(self, provider: str, symbol: str, timeframe: str, 
                        data: pl.DataFrame) -> int:
        """ÏãúÏû• Îç∞Ïù¥ÌÑ∞Î•º SQLiteÏóê Ï†ÄÏû• (UPSERT)"""
        if data.height == 0:
            return 0
            
        # DataFrameÏùÑ ÎîïÏÖîÎÑàÎ¶¨ Î¶¨Ïä§Ìä∏Î°ú Î≥ÄÌôò
        records = []
        for row in data.iter_rows(named=True):
            # KST ÏãúÍ∞ÑÏùÑ UTCÎ°ú Î≥ÄÌôò
            timestamp_kst = row['timestamp']
            if timestamp_kst.tzinfo is None:
                # naive datetimeÏùÄ KSTÎ°ú Í∞ÄÏ†ï
                from zoneinfo import ZoneInfo
                timestamp_kst = timestamp_kst.replace(tzinfo=ZoneInfo("Asia/Seoul"))
            
            timestamp_utc = timestamp_kst.astimezone(timezone.utc)
            
            records.append((
                provider, symbol, timeframe,
                timestamp_utc.replace(tzinfo=None).isoformat(),  # SQLiteÎäî naive datetime ÏÑ†Ìò∏
                timestamp_kst.replace(tzinfo=None).isoformat(),
                float(row['open']),
                float(row['high']),
                float(row['low']),
                float(row['close']),
                float(row['volume'])
            ))
        
        with sqlite3.connect(self.db_path) as conn:
            # UPSERT ÏøºÎ¶¨ (Ï§ëÎ≥µÏãú ÏóÖÎç∞Ïù¥Ìä∏)
            conn.executemany('''
                INSERT OR REPLACE INTO market_data 
                (provider, symbol, timeframe, timestamp_utc, timestamp_kst,
                 open_price, high_price, low_price, close_price, volume)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', records)
            
            conn.commit()
            return len(records)
    
    def get_market_data(self, provider: str, symbol: str, timeframe: str,
                       start_utc: datetime, end_utc: datetime) -> pl.DataFrame:
        """SQLiteÏóêÏÑú ÏãúÏû• Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
        with sqlite3.connect(self.db_path) as conn:
            query = '''
                SELECT timestamp_kst, open_price, high_price, 
                       low_price, close_price, volume
                FROM market_data 
                WHERE provider = ? AND symbol = ? AND timeframe = ?
                  AND timestamp_utc BETWEEN ? AND ?
                ORDER BY timestamp_utc
            '''
            
            cursor = conn.execute(query, (
                provider, symbol, timeframe,
                start_utc.replace(tzinfo=None).isoformat(),
                end_utc.replace(tzinfo=None).isoformat()
            ))
            
            rows = cursor.fetchall()
            
        if not rows:
            return pl.DataFrame(schema={
                "timestamp": pl.Datetime,
                "symbol": pl.Utf8,
                "open": pl.Float64,
                "high": pl.Float64,
                "low": pl.Float64,
                "close": pl.Float64,
                "volume": pl.Float64
            })
        
        # DataFrame ÏÉùÏÑ±
        data = []
        for row in rows:
            timestamp_kst = datetime.fromisoformat(row[0])
            # KST ÌÉÄÏûÑÏ°¥ Ï†ïÎ≥¥ Ï∂îÍ∞Ä
            from zoneinfo import ZoneInfo
            timestamp_kst = timestamp_kst.replace(tzinfo=ZoneInfo("Asia/Seoul"))
            
            data.append({
                "timestamp": timestamp_kst,
                "symbol": symbol,
                "open": row[1],
                "high": row[2],
                "low": row[3],
                "close": row[4],
                "volume": row[5]
            })
        
        result_df = pl.DataFrame(data)
        return result_df
    
    def get_data_range(self, provider: str, symbol: str, timeframe: str) -> Optional[tuple]:
        """Îç∞Ïù¥ÌÑ∞ Î≤îÏúÑ Ï°∞Ìöå (ÏµúÏÜå, ÏµúÎåÄ ÏãúÍ∞Ñ)"""
        with sqlite3.connect(self.db_path) as conn:
            query = '''
                SELECT MIN(timestamp_utc), MAX(timestamp_utc)
                FROM market_data 
                WHERE provider = ? AND symbol = ? AND timeframe = ?
            '''
            cursor = conn.execute(query, (provider, symbol, timeframe))
            result = cursor.fetchone()
            
            if result[0] and result[1]:
                return (
                    datetime.fromisoformat(result[0]),
                    datetime.fromisoformat(result[1])
                )
            return None
    
    def get_data_count(self, provider: str, symbol: str, timeframe: str) -> int:
        """Îç∞Ïù¥ÌÑ∞ Í∞úÏàò Ï°∞Ìöå"""
        with sqlite3.connect(self.db_path) as conn:
            query = '''
                SELECT COUNT(*) FROM market_data 
                WHERE provider = ? AND symbol = ? AND timeframe = ?
            '''
            cursor = conn.execute(query, (provider, symbol, timeframe))
            return cursor.fetchone()[0]
    
    def cleanup_old_data(self, days: int = 180):
        """Ïò§ÎûòÎêú Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨"""
        cutoff_date = datetime.now(timezone.utc) - timedelta(days=days)
        
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute('''
                DELETE FROM market_data 
                WHERE created_at < ?
            ''', (cutoff_date.replace(tzinfo=None).isoformat(),))
            
            deleted_count = cursor.rowcount
            conn.commit()
            
            if deleted_count > 0:
                print(f"üóëÔ∏è {deleted_count}Í∞ú Ïò§ÎûòÎêú Î†àÏΩîÎìú ÏÇ≠Ï†ú ({days}Ïùº Ïù¥Ï†Ñ)")
            
            return deleted_count 